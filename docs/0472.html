<html>
<head>
<title>How to Create a DAO on Velas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在草原上创造刀</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://dappradar.com/blog/how-to-create-a-dao-on-velas">https://web.archive.org/web/https://dappradar.com/blog/how-to-create-a-dao-on-velas</a></blockquote><h2 class="entry-subtitle">Velas为构建分散、高效、透明的DAO提供了理想的基础设施</h2>
<p>团队可以享受在Velas上创建Dao的各种好处。其中包括拥有一个完全自主和透明的组织，利用基于以太坊的智能合约，以接近零的成本享受闪电般的交易速度，等等。T3】</p>



<p><strong>概要:</strong></p>



<ul><li>组织的未来将以DAO的形式出现，Velas为此提供了一个高效的基础设施。</li><li>利用Velas ( <a href="https://web.archive.org/web/20221022164655/https://dappradar.com/hub/token/eth/VLX?from=0x8c543aed163909142695f2d2acd0d55791a9edb9" target="_blank"> VLX </a>)区块链，开发人员可以用多种语言构建Dao，并且支持跨链交互。</li><li>值得注意的是，在构建DAO时，团队需要全面考虑DAO结构、记号组学、社区建立等。</li><li>Dao已经选择加入Velas区块链，以受益于其低成本、高效率和Velas 1亿美元的资助计划。</li><li>本文将向开发人员一步步展示如何在Velas上创建DAO。</li></ul>



<h2>介绍</h2>



<p>虽然<a href="https://web.archive.org/web/20221022164655/https://dappradar.com/rankings/protocol/ethereum" target="_blank">以太坊</a>仍在努力转向节能的利益相关模型，但各种区块链已经出现，以解决以太坊的扩展问题。在所有的替代品中，Velas是最受认可的。</p>



<p>根据DappRadar Token Explorer的数据，Velas ( <a href="https://web.archive.org/web/20221022164655/https://dappradar.com/hub/token/eth/VLX?from=0x8c543aed163909142695f2d2acd0d55791a9edb9" target="_blank"> VLX </a> ) token在过去七天内反弹了9.76%，在撰写本文时的交易价格为0.046。</p>



<p>Velas是一款区块链，继承了Solana的技术优势，并提供了高性能的EVM兼容解决方案。因此，它可以以更高的速度和更低的成本平稳地执行基于以太坊堆栈构建的智能合约和dapps。令人印象深刻的是，Velas可以以接近零的成本每秒处理50，000多个事务(TPS)。</p>



<p>此外，Velas致力于提供一个终极基础设施，以其突破性的技术为分散自治组织(Dao)提供支持。那么，为什么道在区块链世界越来越受欢迎呢？</p>



<p>首先，让我们弄清楚这个问题:<a class=" css-0" href="/web/20221022164655/https://dappradar.com/blog/what-is-a-dao-how-does-it-work/">什么是刀</a>？</p>



<p>简而言之，一个道是一个虚拟的社区领导的实体，没有任何中央领导，决策是通过对区块链的投票作出的。由于这可以带来更民主、透明和公平的组织治理，DAO正在进入商业管理的主流，尤其受到密码社区的青睐。</p>



<p>这篇文章将展示如何在Velas上开始你的刀。在进入这些步骤之前，开发人员需要有一个Velas钱包和自己的VLX，因为dapps通过发送带有一个或多个指令的交易来与Velas区块链进行交互。</p>



<p><a class=" css-0" href="/web/20221022164655/https://dappradar.com/blog/faq-token-swap-on-dappradar/">点击此链接</a>了解如何使用DappRadar令牌交换来获取VLX。</p>



<h2>Velas上的Dao是按比例建造的</h2>



<p>与将规则写在纸上的传统组织不同，DAO的规则和规定是开源编程的，并由智能合同运行。利用Velas区块链，开发人员可以用多种语言构建由智能合约支持的Dao。此外，Velas上的Dao是按比例构建的，因为Velas区块链支持跨链交互。</p>



<p>让我们通过这些步骤在Velas上创建你的刀。</p>



<h3>决定刀的类型</h3>



<p>一个组织的构建需要深思熟虑，一个道的创造也是如此。创造一把刀背后的原因和动机值得深思。这些考虑将有助于确定DAO的最佳结构。你想用你的刀达到什么目的？道的短期和长期愿景是什么？你的项目需要一个分散的、非等级的所有权结构吗？这些只是一些需要思考的示例问题。</p>



<p>组织也可以发挥他们的想象力来提出他们自己的DAO选择，但一般来说，他们涵盖以下类型:</p>



<ul><li>协议DAOs</li><li>格兰特·道斯</li><li>社会道德</li><li>收藏家道斯</li><li>创业道</li><li>媒体Dao</li><li>社交媒体DAOs</li><li>娱乐道</li></ul>



<h3>设计记号组学</h3>



<p>DAOs的目标是取代公司，以自下而上的方式组织各种商业和非商业活动。为了使这些活动顺利进行，自然需要经济激励。因此，战略性地考虑DAOs中令牌的分布和效用对于社区的发展至关重要。</p>



<p>DAO标记可用于:</p>



<ul><li>奖励和激励</li><li>道的治理和表决道的方向</li><li>为您的社区释放其他利益和机会</li></ul>



<p>代币组学的其他关键方面包括代币的初始供应和分配。它们是道的商业计划的一部分；因此，这些事项是投资者在做出投资决定时必须考虑的。</p>



<h3>建立并参与你的社区</h3>



<p>对于第一次构建DAO的团队来说，没有必要太担心，因为市场上有第三方工具可以帮助他们快速启动。</p>



<p>然而，使一个道成功的最关键的部分是其社区中的人。如果一个道有一个积极投入的社区，它更有可能在激烈的竞争中生存下来，甚至茁壮成长。</p>



<p>值得一提的是，建立一个社区并不局限于在Discord、Telegram或Twitter等社交媒体上露面。一个充满活力的社区依赖于拥有相同愿景并共同贡献的建设者、创造者和Web3爱好者。</p>



<h2>一步一步的在草原上创造刀的指南</h2>



<p>在本文的这一章中，我们将向您展示如何在Velas testnet上部署一个实际的DAO智能契约。</p>



<h3>先决条件</h3>



<p>在本教程中，我们将使用<a href="https://web.archive.org/web/20221022164655/https://hardhat.org/" rel="nofollow noopener"> Hardhat </a>进行开发。然而，我们不会在这里讨论安全帽和坚固性的基础知识。所以如果你对这些技术不熟悉，请先装备好扎实和安全帽的基础。</p>



<h3>设置</h3>



<p>对于安装，请在您的机器上创建一个新的Hardhat项目，并删除所有文件(。sol)放在默认创建的合同文件夹中。</p>



<h3>如何创建治理令牌</h3>



<p>像MakerDAO这样基于令牌的成员模型是目前DAO组织的主要形式。因此，我们将指导您创建自己的治理令牌。由于Velas与EVM兼容，我们创建的令牌将是一个ERC20令牌。</p>



<p>这里我们不关心如何向用户分发令牌，因为这不是一个真正的项目。如果想找出令牌分发的策略，建议研究一下MakerDAO这样不同的项目，比较一下。</p>



<p>要创建治理令牌，首先，您需要在contracts文件夹中创建一个名为<em> GovernanceToken.sol </em>的文件，并将以下代码添加到该文件中。</p>



<pre class="wp-block-code"><code>//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract GovernanceERC20 is ERC20 {
    constructor(uint256 initialSupply) ERC20("Governance Token", "GT") {
        _mint(msg.sender, initialSupply);
    }
}</code></pre>



<h3>如何编写DAO智能合约</h3>



<p>由于智能契约是创建全功能DAO的关键部分，我们将一步一步地完成这个过程，并根据需要分别对每个部分进行编码。首先，让我们创建一个准系统合同，并将其添加到一个名为<em> DAO.sol. </em>的文件中。</p>



<pre class="wp-block-code"><code>//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DAO {

}</code></pre>



<h4>创建构造函数</h4>



<p>现在，我们将使这个DAO契约与任何ERC20令牌兼容。</p>



<p>通过使用IERC20接口，我们可以与任何ERC20令牌进行交互。为此，我们必须从<em> Openzeppelin库</em>导入IERC20接口，然后声明一个使用IERC20接口的变量<em> governancetoken </em>。</p>



<p>现在，我们需要创建智能合约的构造函数。在这种情况下，我们将使用一个名为<em> _governancetoken </em>的参数，这是我们的治理令牌的地址。在构造函数内部，我们将使用IERC20给<em> governancetoken </em>变量赋值，并将其传递给<em> address _governancetoken </em>。</p>



<pre class="wp-block-code"><code>//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DAO {
    IERC20 public governancetoken;

    constructor(address _governancetoken) {
        governancetoken = IERC20(_governancetoken);
    }
}</code></pre>



<h4>定义建议结构</h4>



<p>每当成员创建提案时，他们都必须使用预定义的格式。我们将通过使用struct数据类型来定义每个建议的格式来实现这一点。现在，让我们创建一个名为<em> Proposal </em>的结构，如下所示。</p>



<pre class="wp-block-code"><code>  struct Proposal {
        address proposer;
        string name;
        uint256 votesForApprove;
        uint256 votesForDeny;
        uint256 startTime;
        Status status;
    }</code></pre>



<p>正如您在上面看到的，每个属性都有一个与之关联的数据类型。您将知道这些数据类型中的大多数，但是我们已经添加了一个名为<em> Status </em>的自定义数据类型。关于数据类型“状态”的更多细节将在下面的章节中解释。</p>



<h4>跟踪建议</h4>



<p>创建提案后，我们必须将其保存在仓库中。为此，我们使用建议映射，将index(在本例中为uint256)作为键，将<em>建议</em>作为值。将映射添加到我们的智能契约中，并将其命名为public proposals，使其对公众可见。</p>



<pre class="wp-block-code"><code>mapping(uint256 =&gt; Proposal) public proposals;</code></pre>



<h4>其他全局变量和枚举</h4>



<p>为了让智能契约完全发挥作用，我们还需要向它添加一些其他的全局变量和枚举。</p>



<p>首先，我们将添加<em>状态</em>枚举。我们前面提到的这种数据类型定义了一个提议的状态。枚举帮助我们将变量的值限制为预定义的值。通常，我们希望将建议结构中状态变量的值限制为以下值。</p>



<ul><li>被认可的</li><li>拒绝</li><li>InProgress</li><li>期满</li></ul>



<p>让我们逐一检查一下。因此，如果持有51%治理令牌的成员批准该提议，则状态将为<em>批准</em>，同样的条件也适用于<em>拒绝</em>状态。</p>



<p>如果赞成或反对都不超过投票总数的51%，提案的状态将更改为<em>过期</em>。当然，当提案处于投票阶段时，其状态将显示为<em>正在进行</em>。</p>



<p>我们还将为单个成员的投票类型创建一个枚举。这将限制成员的投票选项为<em>赞成</em>或<em>反对</em>。</p>



<pre class="wp-block-code"><code>enum Option { Approve, Deny }
    enum Status { Approved, Denied, InProgress, Expired}</code></pre>



<p>此时此刻，我们还需要两个变量。一个是在我们将提案添加到提案映射时为每个提案提供一个索引，另一个是存储投票周期的值。我们将保持所有提案的固定投票期，即7天。</p>



<pre class="wp-block-code"><code>uint256 public indx;
    uint256 constant public VOTING_PERIOD = 7 days;</code></pre>



<p>由于我们已经完成了本教程的一半，我们的智能契约应该类似于下面这样。</p>



<pre class="wp-block-code"><code>//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DAO {
    
    enum Option { Approve, Deny }
    enum Status { Approved, Denied, InProgress, Expired}

    struct Proposal {
        address proposer;
        string name;
        uint256 votesForApprove;
        uint256 votesForDeny;
        uint256 startTime;
        uint256 votingPeriod;
        Status status;
    }

    mapping(uint256 =&gt; Proposal) public proposals;

    IERC20 public governancetoken;


    uint256 public indx;
    uint256 constant public VOTING_PERIOD = 7 days;

    constructor(address _governancetoken) {
        governancetoken = IERC20(_governancetoken);
    }
}</code></pre>



<h4>限制访问成员</h4>



<p>因为在一个DAO中通常有许多类型的成员，所以不是所有的成员在一个DAO中都被同等对待。所以我们想限制一些DAO成员对某些功能的访问。为此，我们将使用一个修饰符。这个修饰符叫做<em> isMember </em>。在我们的例子中，我们仅使用它来允许治理令牌持有者访问该函数。</p>



<pre class="wp-block-code"><code> modifier isMember {
        uint256 balance = governancetoken.balanceOf(msg.sender);
        require(balance &gt; 0, "Not a member of quorum");
        _;
    }</code></pre>



<h4>用于创建建议的功能</h4>



<p>所有准备工作完成后，让我们编写智能合同的核心功能，即建议书创建。那么如何编写一个允许成员(在本例中，是持有治理令牌的人)创建提议的函数呢？</p>



<pre class="wp-block-code"><code> function createProposal(string memory _name) public isMember returns(Proposal memory) {

        proposals[indx] = Proposal(
            msg.sender,
            _name,
            0,
            0,
            block.timestamp,
            VOTING_PERIOD,
            Status.InProgress
        );

        indx++;

        return proposals[indx-1];
    }</code></pre>



<p>创建提议时，提议者只需在调用函数的同时提交提议的名称。为此，我们有一个名为<em> _name </em>的参数，类型为string。</p>



<p>此功能的访问权限仅限于治理成员。所以让我们用<em> isMember </em>修饰符来确定<em> public </em>的可见性。在内部，我们使用<em> indx </em>作为一个键来存储一个带有提议映射的提议。最后，我们将<em> indx </em>增加1，并返回创建的提议。</p>



<p>在创建一个建议时，我们必须使用所有值作为参数的建议结构。设置新建议值的方法如下。</p>



<ul><li><em>提议者</em>:保存调用函数的人的地址</li><li><em> name </em>:设置为字符串，作为函数参数传递</li><li><em> voteForApprove </em>:设置为0</li><li><em> voteForDeny </em>:设置为0</li><li><em>开始时间</em>:当前块时间戳</li><li><em>状态</em>:设置为状态。正在进行中</li></ul>



<h4>跟踪投票的成员</h4>



<p>创建提案后，投票将开始。现在最重要的是确保不让议员投两次票。我们将使用嵌套映射，其中第一个映射将建议索引(<em> indx </em>)作为键，布尔值作为值，外部映射将该地址作为键，前一个映射作为值。</p>



<p>这样，我们将跟踪每个成员的地址，以及他们是否对某个特定的提案投了票。</p>



<pre class="wp-block-code"><code>  mapping(address =&gt; mapping(uint256 =&gt; bool)) public voted;</code></pre>



<h4>投票功能</h4>



<p>现在到了激动人心的部分，编写一个允许成员投票的函数。投票函数将接受两个参数。第一个是提案的索引(<em> _proposal </em>)，第二个是投票选项(<em> Option </em> struct)。</p>



<p>如前所述，这个函数仍然只能由带有<em> isMember </em>修饰符的成员访问。因为我们将更改智能合约的状态，所以它需要对公众可见。</p>



<h4>投票功能是如何工作的？</h4>



<p>首先，我们需要检索存储在提议映射中的提议，供用户投票。我们可以使用映射名称后跟带键的方括号来访问任何提议。</p>



<p>这里我们将使用<em>提议[_提议] </em>。将建议存储在名为<em>建议、</em>的变量中，变量的类型为<em>建议</em>，后跟关键字<em>存储</em>。关键字存储允许我们访问存储的数据，数据会根据我们所做的更改而更新。</p>



<h4>为投票添加更多条件</h4>



<p>我们创建投票函数的工作不止于此，因为我们需要添加一些条件来限制投票。比如投票期已经结束，或者用户已经投票了怎么办？</p>



<p>在这些情况下，我们将对它们都使用<em> require </em>函数。在第一个条件中，我们想要检查投票是否已经结束。为此，我们可以使用下面的语句。</p>



<p><em>proposal . start time+VOTING _ PERIOD&gt;= block .时间戳</em></p>



<p>如果条件被满足，它将抛出一个错误，说“<em>已经投票了！</em>”。</p>



<p>在第二个条件中，我们希望检查用户是否已经投票。为此，我们可以检查用户投票地址的标志是否为假。使用下面的陈述可以帮助我们实现这一点。</p>



<p><em>已投票的[邮件发送者][_提案] ==假</em></p>



<p>如果该标志为真，它将显示一个错误消息“已经投票了！”。</p>



<p>每当用户投票时，他们的治理令牌的余额将被视为该用户所投的票数。因此，我们将相应地更新投票。要获得用户拥有的令牌数，我们可以使用<em>治理令牌</em>的方法的<em>balance。</em></p>



<p>如果用户投票批准，则将余额添加到<em> votesForApprove。</em>相反，如果用户投票否定，那么给<em> votesForDeny </em>加余额。最后，将该地址的<em>投票</em>标志设置为<em>真</em>。</p>



<pre class="wp-block-code"><code>  function vote(uint256 _proposal, Option _vote) public isMember {
        Proposal storage proposal = proposals[_proposal];
        require(proposal.startTime + VOTING_PERIOD &gt;= block.timestamp, "Voting Ended");
        require(voted[msg.sender][_proposal] == false, "Already Voted!");
        
        uint256 balance = governancetoken.balanceOf(msg.sender);

        if (_vote == Option.Approve) {
            proposal.votesForApprove = proposal.votesForApprove + balance;
        } else {
            proposal.votesForDeny = proposal.votesForDeny + balance;
        }

        voted[msg.sender][_proposal] = true;
    }</code></pre>



<h4>更新建议的状态</h4>



<p>现在我们已经创建了投票函数，下一步是编写一个函数，在提案结束时更新提案的状态。“其他全局变量和枚举”部分解释了任何提案的不同法规的含义。</p>



<p>现在让我们继续讨论如何做出决策和更新提案的状态。对于<em> updateStatus </em>函数，我们将提案的索引作为函数参数。该流程还从从建议映射中检索建议开始。然后我们需要检查提案是否还在投票期内。如果没有，我们可以进入下一步。</p>



<p>为了检查提议的结果，我们需要做一些计算，但是怎么做呢？首先，我们必须获得治理令牌供应量的一半(<em> halfOfSupply </em>)。为此，我们需要使用<em> governancetoken </em>的<em> totalSupply </em>函数获得总供应量，然后除以2。</p>



<p>如果<em> votesForApprove </em>大于<em> halfOfSupply，</em>则将状态设置为待批准(<em>状态)。已批准</em>。如果<em> votesForDeny </em>大于<em> halfOfSupply </em>，则将状态设置为拒绝(<em>状态)。被拒绝</em>)。条件都不满足怎么办？然后我们可以将状态设置为过期(<em> Status.expired </em>)。</p>



<pre class="wp-block-code"><code>  function updateStatus(uint256 _proposal) public returns(Status){
        Proposal storage proposal = proposals[_proposal];
        require(proposal.startTime + VOTING_PERIOD &lt;= block.timestamp, "Voting In Progress");
        uint256 halfOfSupply = governancetoken.totalSupply() / 2;

        if (proposal.votesForApprove &gt; halfOfSupply) {
            proposal.status = Status.Approved;
        } else if (proposal.votesForDeny &gt; halfOfSupply) {
            proposal.status = Status.Denied;
        } else {
            proposal.status = Status.Expired;
        }

        return proposal.status;
    }</code></pre>



<h4>整个智能合同的预览</h4>



<p>现在，最困难的部分已经过去了。让我们看看我们取得了什么成就。DAO智能协定应该如下所示。</p>



<pre class="wp-block-code"><code>//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DAO {
    
    enum Option { Approve, Deny }
    enum Status { Approved, Denied, InProgress, Expired}

    struct Proposal {
        address proposer;
        string name;
        uint256 votesForApprove;
        uint256 votesForDeny;
        uint256 startTime;
        Status status;
    }


    mapping(uint256 =&gt; Proposal) public proposals;

    mapping(address =&gt; mapping(uint256 =&gt; bool)) public voted;

    IERC20 public governancetoken;

    uint256 public indx;
    uint256 constant public VOTING_PERIOD = 7 days;

    constructor(address _governancetoken) {
        governancetoken = IERC20(_governancetoken);
    }
    
    function createProposal(string memory _name) public isMember returns(Proposal memory) {

        proposals[indx] = Proposal(
            msg.sender,
            _name,
            0,
            0,
            block.timestamp,
            Status.InProgress
        );

        indx++;

        return proposals[indx-1];
    }
        
    function vote(uint256 _proposal, Option _vote) public isMember {
        Proposal storage proposal = proposals[_proposal];
        require(proposal.startTime + VOTING_PERIOD &gt;= block.timestamp, "Voting Ended");
        require(voted[msg.sender][_proposal] == false, "Already Voted!");
        
        uint256 balance = governancetoken.balanceOf(msg.sender);

        if (_vote == Option.Approve) {
            proposal.votesForApprove = proposal.votesForApprove + balance;
        } else {
            proposal.votesForDeny = proposal.votesForDeny + balance;
        }

        voted[msg.sender][_proposal] = true;
    }

    function updateStatus(uint256 _proposal) public returns(Status){
        Proposal storage proposal = proposals[_proposal];
        require(proposal.startTime + VOTING_PERIOD &lt;= block.timestamp, "Voting In Progress");
        uint256 halfOfSupply = governancetoken.totalSupply() / 2;

        if (proposal.votesForApprove &gt; halfOfSupply) {
            proposal.status = Status.Approved;
        } else if (proposal.votesForDeny &gt; halfOfSupply) {
            proposal.status = Status.Denied;
        } else {
            proposal.status = Status.Expired;
        }

        return proposal.status;
    }

    modifier isMember {
        uint256 balance = governancetoken.balanceOf(msg.sender);
        require(balance &gt; 0, "Not a member of quorum");
        _;
    }
}</code></pre>



<h3>在Velas Testnet上部署合同</h3>



<p>恭喜你！你离经营自己的道就一步之遥了。您准备好在Velas上部署您的智能合约了吗？</p>



<p>为了部署契约，我们必须编写一个部署契约的脚本。在<em>脚本</em>文件夹中创建一个<em> deploy.js </em>文件，并将以下代码粘贴到该文件中。</p>



<pre class="wp-block-code"><code>const hre = require("hardhat");

async function main () {
  // We get the contract to deploy
  const GovernanceToken = await hre.ethers.getContractFactory('GovernanceERC20');
  console.log("Deploying Governance Token...");
  const governanceToken = await GovernanceToken.deploy(1000);
  await governanceToken.deployed();
  console.log('Governance Token deployed to:', governanceToken.address);

  const DAO = await hre.ethers.getContractFactory('DAO');
  console.log('Deploying DAO...');
  const dao = await DAO.deploy(governanceToken.address);
  await dao.deployed();
  console.log('DAO deployed to:', dao.address);
}

main()
  .then(() =&gt; process.exit(0))
  .catch(error =&gt; {
    console.error(error);
    process.exit(1);
});</code></pre>



<p>在部署合同之前，我们必须更改<em> hardhat.config.js </em>文件中的<em> module.exports </em>。</p>



<pre class="wp-block-code"><code>module.exports = {
  solidity: "0.8.4",
  networks: {
    velastestnet: {
      url: `https://evmexplorer.testnet.velas.com/rpc`,
      accounts: [process.env.PRIVATE_KEY]
    }
  }
};</code></pre>



<p>这将Velas testnet的详细信息添加到我们的hardhat配置中。此外，在部署契约之前，您必须将钱包的私钥添加到<em>中。env </em>文件。此外，确保你的钱包里有一些testnet Velas令牌。你可以在这里从<a href="https://web.archive.org/web/20221022164655/https://t.me/velas_faucet_bot" rel="nofollow noopener">那里获得testnet代币。</a></p>



<p>现在一切都设置好了，在终端中运行下面的命令。</p>



<pre class="wp-block-code"><code>npx hardhat run scripts/deploy.js --network velastestnet</code></pre>



<p>检查输出。</p>



<pre class="wp-block-code"><code>Deploying Governance Token...
Governance Token deployed to: 0x158C94E88d3AC6967e7690eAeac3FB6c8BF68502
Deploying DAO...
DAO deployed to: 0x190b8BF3f887D4F00AcF57e95AE478270Cc7fdC5</code></pre>



<p>如果您的输出与上面看到的类似，那么您已经成功地部署了契约！</p>



<p>最后但同样重要的是，与创建DAO智能合约相关的所有信息都在<a href="https://web.archive.org/web/20221022164655/https://github.com/nikbhintade/velas-dao" target="_blank" rel="nofollow noopener">这个repo </a>中。如果你想检查代码或查看智能合同的测试，<a href="https://web.archive.org/web/20221022164655/https://github.com/nikbhintade/velas-dao" target="_blank" rel="nofollow noopener">查看这个页面</a>。</p>



<h2>最后的话</h2>



<p>创业团队选择了Velas区块链作为构建Dao的基础设施。例如，VeleroDAO，基于MakerDAO协议的DeFi平台，已经加入了Velas区块链。</p>



<p>基于Velas的构建意味着VeleroDAO可以享受闪电般的交易速度和成本效益，而不会影响与以太坊的互操作性。最重要的是，VereloDAO也是创业团队如何受益于<a rel="nofollow noopener" href="https://web.archive.org/web/20221022164655/https://velasgrants.typeform.com/GrantsProgram" target="_blank"> Velas grant计划的一个很好的例子。</a></p>



<p>该计划提供1亿美元的奖励，以支持开发者和创作者将他们的想法付诸行动。它不仅促进了草原生态系统的发展，也加速了区块链生态系统的多样化。<a href="https://web.archive.org/web/20221022164655/https://velasgrants.typeform.com/GrantsProgram" target="_blank" rel="nofollow noopener">现在就加入快速发展的Velas生态系统</a>。</p>



<p>关于Velas的更多信息</p>



<p><a href="https://web.archive.org/web/20221022164655/https://velas.com/?utm_source=dappradar&amp;utm_medium=about_velas" target="_blank" rel="nofollow noopener">网站</a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://velas.com/pdf/whitepaper.pdf" target="_blank" rel="nofollow noopener">白皮书</a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://docs.velas.com/grants/?utm_source=dappradar&amp;utm_medium=about_velas" rel="nofollow noopener">资助项目</a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://www.facebook.com/velasblockchain" target="_blank" rel="nofollow noopener">脸书</a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://www.linkedin.com/company/velas-ag" target="_blank" rel="nofollow noopener"> LinkedIn </a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://twitter.com/VelasBlockchain" target="_blank" rel="nofollow noopener">推特</a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://t.me/VelasOfficial" target="_blank" rel="nofollow noopener">电报通知</a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://t.me/velascommunity" target="_blank" rel="nofollow noopener">电报社区</a></p>



<p><a href="https://web.archive.org/web/20221022164655/http://instagram.com/velas.blockchain" target="_blank" rel="nofollow noopener"> Instagram </a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://discord.gg/CTcKpPc" target="_blank" rel="nofollow noopener">不和</a></p>



<p><a href="https://web.archive.org/web/20221022164655/https://youtube.com/c/VelasOfficial" target="_blank" rel="nofollow noopener"> YouTube </a></p>



<p><a rel="nofollow noopener" href="https://web.archive.org/web/20221022164655/https://velasblockchain.medium.com/" target="_blank">中等</a></p>



<p class="has-background" style="background-color:#d6d6d6"><strong>免责声明</strong> —这是一篇赞助文章。DappRadar不认可本页面上的任何内容或产品。DappRadar旨在提供准确的信息，但读者应该在采取行动之前总是自己做研究。DappRadar的文章不能被认为是投资建议。</p>



<p/>
    
</body>
</html>